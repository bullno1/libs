<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blibs: bspscq.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">blibs
   </div>
   <div id="projectbrief">Misc modules</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bspscq.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lock-free single-producer single-consumer (spsc) queue.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;threads.h&gt;</code><br />
<code>#include &lt;stdatomic.h&gt;</code><br />
</div>
<p><a href="bspscq_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbspscq__signal__t.html">bspscq_signal_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbspscq__s.html">bspscq_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5fe965d4a3400633f0fa3d5393fc5ec5" id="r_a5fe965d4a3400633f0fa3d5393fc5ec5"><td class="memItemLeft" align="right" valign="top"><a id="a5fe965d4a3400633f0fa3d5393fc5ec5" name="a5fe965d4a3400633f0fa3d5393fc5ec5"></a>
typedef struct <a class="el" href="structbspscq__s.html">bspscq_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bspscq_t</b></td></tr>
<tr class="separator:a5fe965d4a3400633f0fa3d5393fc5ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9e4c39c711b3c3ba9dd56eefe1acef00" id="r_a9e4c39c711b3c3ba9dd56eefe1acef00"><td class="memItemLeft" align="right" valign="top">BSPSCQ_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bspscq_8h.html#a9e4c39c711b3c3ba9dd56eefe1acef00">bspscq_init</a> (<a class="el" href="structbspscq__s.html">bspscq_t</a> *queue, void **values, unsigned int size)</td></tr>
<tr class="memdesc:a9e4c39c711b3c3ba9dd56eefe1acef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a queue.  <br /></td></tr>
<tr class="separator:a9e4c39c711b3c3ba9dd56eefe1acef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb2c3fc2920bcca29189b8376883fd" id="r_a03eb2c3fc2920bcca29189b8376883fd"><td class="memItemLeft" align="right" valign="top">BSPSCQ_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bspscq_8h.html#a03eb2c3fc2920bcca29189b8376883fd">bspscq_cleanup</a> (<a class="el" href="structbspscq__s.html">bspscq_t</a> *queue)</td></tr>
<tr class="memdesc:a03eb2c3fc2920bcca29189b8376883fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up a queue.  <br /></td></tr>
<tr class="separator:a03eb2c3fc2920bcca29189b8376883fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dd8c6a12c06f22ff79e45043d82c6e" id="r_a81dd8c6a12c06f22ff79e45043d82c6e"><td class="memItemLeft" align="right" valign="top">BSPSCQ_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bspscq_8h.html#a81dd8c6a12c06f22ff79e45043d82c6e">bspscq_produce</a> (<a class="el" href="structbspscq__s.html">bspscq_t</a> *queue, void *item, bool wait)</td></tr>
<tr class="memdesc:a81dd8c6a12c06f22ff79e45043d82c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item into the queue.  <br /></td></tr>
<tr class="separator:a81dd8c6a12c06f22ff79e45043d82c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7005c5129f0eaf7f6561cb0652a9c90" id="r_ad7005c5129f0eaf7f6561cb0652a9c90"><td class="memItemLeft" align="right" valign="top">BSPSCQ_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bspscq_8h.html#ad7005c5129f0eaf7f6561cb0652a9c90">bspscq_consume</a> (<a class="el" href="structbspscq__s.html">bspscq_t</a> *queue, bool wait)</td></tr>
<tr class="memdesc:ad7005c5129f0eaf7f6561cb0652a9c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an item from the queue.  <br /></td></tr>
<tr class="separator:ad7005c5129f0eaf7f6561cb0652a9c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lock-free single-producer single-consumer (spsc) queue. </p>
<p>No memory allocation is made and the user is responsible for managing the queue's storage as well as messages' lifecycle. Since the queue has a fixed size, it is possible to just preallocate the messages and use them in a round-robin manner from the producer. Ideally, the preallocated buffer should be at least the size of the queue plus 2. This is because in the worst case:</p>
<ul>
<li>The queue is full.</li>
<li>One message is being prepared by the producer.</li>
<li>One message is being processed by the consumer.</li>
</ul>
<p>The queue can optionally block on production or consumption. This makes it suitable to be used as a message queue to a background thread that waits for jobs to be dispatched instead of busy spinning.</p>
<p>Based on: <a href="https://github.com/mattiasgustavsson/libs/blob/main/thread.h">https://github.com/mattiasgustavsson/libs/blob/main/thread.h</a>. Using C11 threading and atomic primitives instead of platform-specific API. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a03eb2c3fc2920bcca29189b8376883fd" name="a03eb2c3fc2920bcca29189b8376883fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03eb2c3fc2920bcca29189b8376883fd">&#9670;&#160;</a></span>bspscq_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSPSCQ_API void bspscq_cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbspscq__s.html">bspscq_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up a queue. </p>
<p>All operations on the queue after this will be undefined behaviour. The user is responsible for stopping both the producer and the consumer before this is called. Usually, this can be done by sending the consumer a "stop" message through the queue and join with its thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to clean up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7005c5129f0eaf7f6561cb0652a9c90" name="ad7005c5129f0eaf7f6561cb0652a9c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7005c5129f0eaf7f6561cb0652a9c90">&#9670;&#160;</a></span>bspscq_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSPSCQ_API void * bspscq_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbspscq__s.html">bspscq_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an item from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to produce into. </td></tr>
    <tr><td class="paramname">wait</td><td>Whether the caller will be blocked if the queue is not empty. The caller will be unblocked once at least one item has been produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An item from the queue or NULL if the queue is empty. If <code>wait</code> is true, this will never be NULL. If <code>wait</code> is false, this may return NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="a9e4c39c711b3c3ba9dd56eefe1acef00" name="a9e4c39c711b3c3ba9dd56eefe1acef00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4c39c711b3c3ba9dd56eefe1acef00">&#9670;&#160;</a></span>bspscq_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSPSCQ_API void bspscq_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbspscq__s.html">bspscq_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to initialize. </td></tr>
    <tr><td class="paramname">values</td><td>An array of pointers to be used as the queue's storage. It must have at lease <code>size</code> elements. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the queue. This must be a power of 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bspscq_8h.html#a81dd8c6a12c06f22ff79e45043d82c6e" title="Put an item into the queue.">bspscq_produce</a> </dd>
<dd>
<a class="el" href="bspscq_8h.html#ad7005c5129f0eaf7f6561cb0652a9c90" title="Get an item from the queue.">bspscq_consume</a> </dd></dl>

</div>
</div>
<a id="a81dd8c6a12c06f22ff79e45043d82c6e" name="a81dd8c6a12c06f22ff79e45043d82c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dd8c6a12c06f22ff79e45043d82c6e">&#9670;&#160;</a></span>bspscq_produce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSPSCQ_API bool bspscq_produce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbspscq__s.html">bspscq_t</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an item into the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to produce into. </td></tr>
    <tr><td class="paramname">item</td><td>Pointer to the item. </td></tr>
    <tr><td class="paramname">wait</td><td>Whether the caller will be blocked if the queue is full. The caller will be unblocked once at least one item has been consumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the item was successfully put into the queue. If <code>wait</code> is true, this will always be true. If <code>wait</code> is false, this may return false if the queue is already full. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
